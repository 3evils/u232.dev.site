/**
 * Copyright (c) 2017 Xiamen Yaji Software Co.Ltd. All rights reserved.
 * Created by lizhiyi on 2018/3/1.
 */

// through2 是一个对 node 的 transform streams 简单封装
var through = require('through2');
var gutil = require('gulp-util');

var request = require('request');
var path = require('path');
var fs = require('fs');
var server = require('./server');
var skipImgs = [],
    compressInfos = [];
var compressNum = 0;    //第三方压缩工具一次最多10张，需重启

// 常量
var PLUGIN_NAME = 'gulp-imgminify';
var log = gutil.log.bind(null, PLUGIN_NAME);

// 插件级别函数 (处理文件)
function gulpPrefixer() {
    //启动服务器
    server.start();

    // 创建一个让每个文件通过的 stream 通道
    var stream = through.obj(function (file, enc, callback) {
        var self = this;

        if (file.isNull()) {
            return callback(null, file);
        }

        if (file.isStream()) {
            return callback(createError(file, 'Streaming not supported'));
        }

        if (file.isBuffer()) {
            imgminify(file, function (data) {
                var outFile = file.clone();

                if (data) {
                    outFile.contents = data;
                }
                return callback(null, outFile);
            });
        }
    });

    stream.on('error', function (err) {
            log(': error ', gutil.colors.red(err));
        })
     .on('end', function () {
            var str = '',
                total = 0, orginTotal = 0,
                ratio;

            compressInfos.forEach(function(e) {
                total += e.size;
                orginTotal += e.originSize;
            });

            ratio = ( parseFloat(total/orginTotal, 10).toFixed(4) * 100 || 0) + '%';

            str += ': ' + gutil.colors.blue('[compress completed] ');
            str += 'skiped: ' + gutil.colors.red(skipImgs.length) + ' imgs, ';
            str += 'compressed: ' + gutil.colors.green(compressInfos.length) + ' imgs, ';
            str += 'totalSize: ' + gutil.colors.green(ratio);
            log(str);

            server.close();
        });

    return stream;
}

function delayCallImgMinify(file, callback) {
    setTimeout(function () {
        imgminify(file, callback);
    }, 200);
}

function imgminify(file, callback) {
    if (server.isServerConnected) {
        if (compressNum < 10) {
            reqCompress(file, callback);
        } else {
            //已经超过十张需要重启server
            server.reStart(function () {
                compressNum = 0;
                delayCallImgMinify(file, callback);
            });
        }
    } else {
        delayCallImgMinify(file, callback);
    }
}

function reqCompress(file, callback) {
    log(': [imgminify request]', file.path);
    compressNum++;
    request({
        url: server.getUploadUrl(),
        method: "post",
        headers: {
            "Accept" : "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
            "Accept-Encoding" : "gzip, deflate",
            "Accept-Language" : "zh-cn,zh;q=0.8,en-us;q=0.5,en;q=0.3",
            "Cache-Control" : "no-cache",
            "Connection"  : "keep-alive"
        },
        body: JSON.stringify({"paths": [file.path]})
    }, function(error, response, body) {
        var results, filename;

        if(!error) {
            filename = path.basename(file.path);
            results = JSON.parse(body);

            if(results.files && results.files.length > 0) {
                var item = results.files[0]; //现在是一张张传，后期看需求是否改成批量传...
                var originalSize = Number(item["originalSize"]);
                var url = server.getDownloadUrl(item["id"]);

                setTimeout(function() {
                    request.get({ url: url, encoding: null }, function (err, res, body) {
                        if (err) {
                            skipImgs.push(filename);
                            log('[error]: ', filename + ' ' + err);
                        } else if (res.statusCode === 404) {
                            skipImgs.push(filename);
                            log(gutil.colors.red(`[error]: ${filename} compress failed!`));
                        } else {
                            var compressSize = Number(res.headers["content-length"]);
                            var ratio = compressSize / originalSize;

                            log(': [compressing]', gutil.colors.green('Ok ') +
                                file.relative
                                + gutil.colors.green(' (' + (ratio * 100).toFixed(1) + '%)'));

                            compressInfos.push({
                                name: filename,
                                size: compressSize,
                                ratio: 1 - ratio,
                                originSize: originalSize
                            });
                        }

                        callback(err ? null : new Buffer(body));
                        // callback(null);
                    });
                }, 1000);

            } else {
                // log('[error]: ', filename + ' ' + results.message);
                skipImgs.push(filename);
                callback(null);
            }
        } else {
            skipImgs.push(filename);
            callback(null);
        }
    });
}

module.exports = gulpPrefixer;